{"version":3,"file":"submitSync.js","sourceRoot":"/source/","sources":["submitSync.ts"],"names":[],"mappings":"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","sourcesContent":["import * as events from \"events\";\nimport * as net from \"net\";\nimport * as stream from \"stream\";\nimport * as child from \"child_process\";\nimport * as tls from \"tls\";\nimport * as http from \"http\";\nimport * as crypto from \"crypto\";\nimport https = require('https');\nimport url = require('url');\nimport { StringDecoder } from 'string_decoder';\nexport interface SubmissionCallback {\r\n  (status: number, message: string, data?: string, headers?: Object): void;\r\n}\r\n\nexport interface SubmissionRequest {\r\n  apiKey: string;\r\n  userAgent: string;\r\n  method: string;\r\n  url: string;\r\n  data: string;\r\n}\r\n\n                                                                                                                    \r\n\r\nexport interface ISubmissionAdapter {\r\n  sendRequest(request: SubmissionRequest, callback?: SubmissionCallback, isAppExiting?: boolean): void;\r\n}\r\n\n                                                                                                                                                                                                                                                                                                                            \r\n\r\nexport class NodeSubmissionAdapter implements ISubmissionAdapter {\r\n  public sendRequest(request: SubmissionRequest, callback?: SubmissionCallback, isAppExiting?: boolean) {\r\n    if (isAppExiting) {\r\n      this.sendRequestSync(request, callback);\r\n      return;\r\n    }\r\n\r\n    let parsedHost = url.parse(request.url);\r\n\r\n    let options: https.RequestOptions = {\r\n      auth: `client:${request.apiKey}`,\r\n      headers: {},\r\n      hostname: parsedHost.hostname,\r\n      method: request.method,\r\n      port: parsedHost.port && parseInt(parsedHost.port, 10),\r\n      path: request.url\r\n    };\r\n\r\n    options.headers['User-Agent'] = request.userAgent;\r\n\r\n    if (request.method === 'POST') {\r\n      options.headers = {\r\n        'Content-Type': 'application/json',\r\n        'Content-Length': new Buffer(request.data).length\r\n      };\r\n    }\r\n\r\n    let protocol = (parsedHost.protocol === 'https' ? https : http);\r\n    let clientRequest: http.ClientRequest = protocol.request(options, (response: http.IncomingMessage) => {\r\n      let body = '';\r\n      response.setEncoding('utf8');\r\n      response.on('data', (chunk) => body += chunk);\r\n      response.on('end', () => this.complete(response, body, response.headers, callback));\r\n    });\r\n\r\n    clientRequest.on('error', (error: Error) => callback && callback(500, error.message));\r\n    clientRequest.end(request.data);\r\n  }\r\n\r\n  private complete(response: http.IncomingMessage, responseBody: string, responseHeaders: Object, callback: SubmissionCallback): void {\r\n    let message: string;\r\n    if (response.statusCode === 0) {\r\n      message = 'Unable to connect to server.';\r\n    } else if (response.statusCode < 200 || response.statusCode > 299) {\r\n      message = response.statusMessage || (<any>response).message;\r\n    }\r\n\r\n    callback && callback(response.statusCode || 500, message, responseBody, responseHeaders);\r\n  }\r\n\r\n  private sendRequestSync(request: SubmissionRequest, callback: SubmissionCallback): void {\r\n    let requestJson = JSON.stringify(request);\r\n    let res = child.spawnSync(process.execPath, [require.resolve('./submitSync.js')],\r\n      {\r\n        input: requestJson,\r\n        stdio: ['pipe', 'pipe', process.stderr]\r\n      });\r\n\r\n    let out = res.stdout.toString();\r\n    let result = JSON.parse(out);\r\n\r\n    callback && callback(result.status, result.message, result.data, result.headers);\r\n  }\r\n}\r\n\n                                                                                                                                                                                                                                      \r\n\r\nlet decoder = new StringDecoder('utf8');\r\nlet strings: string[] = [];\r\n\r\nlet jsonStream = new stream.Writable();\r\njsonStream._write = (chunk: Buffer | string, encoding: string, next: Function) => {\r\n  strings.push(decoder.write(<Buffer>chunk));\r\n  next();\r\n};\r\n\r\njsonStream.on('finish', () => {\r\n  let json = strings.join('');\r\n  let request: SubmissionRequest = JSON.parse(json);\r\n  let adapter = new NodeSubmissionAdapter();\r\n  adapter.sendRequest(request, (status, message, data, headers) => {\r\n    let result = {\r\n      status,\r\n      message,\r\n      data,\r\n      headers\r\n    };\r\n    process.stdout.write(JSON.stringify(result));\r\n    process.exit(0);\r\n  });\r\n});\r\n\r\nprocess.stdin.pipe(jsonStream);\r\n\n"]}